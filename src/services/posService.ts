import { supabase } from '@/integrations/supabase/client';

// Types based on your existing migration (supabase/migrations/20250625050233-....sql)
// Re-defining here for service layer, can be moved to a shared types file later.
export interface POSMenuCategory {
  id: string;
  name: string;
  description?: string | null;
  type?: string; // 'food', 'drink', 'charging'
  display_order?: number | null;
  is_active?: boolean;
  created_at?: string;
}

export interface POSMenuItem {
  id: string;
  category_id: string; // FK to pos_menu_categories
  name: string;
  description?: string | null;
  price: number; // Corresponds to 'price' DECIMAL(10,2)
  cost_price?: number | null;
  vat_rate?: number | null; // Corresponds to 'vat_rate' DECIMAL(5,2)
  vat_inclusive?: boolean;
  image_url?: string | null;
  sku?: string | null;
  stock_quantity?: number | null;
  track_stock?: boolean;
  is_available?: boolean;
  display_order?: number | null;
  created_at?: string;
}

export interface CartItemForSubmit {
  menu_item_id: string;
  item_name: string; // Name of the item at time of order
  quantity: number;
  unit_price: number; // Price at time of order
  vat_rate: number; // VAT rate applied
  vat_amount: number; // Calculated VAT amount for the item
  total_amount: number; // quantity * unit_price (or however total is derived with VAT)
  notes?: string | null;
}

export interface OrderSubmissionData {
  cashier_id?: string | null; // Links to pos_users.auth_user_id or pos_users.id depending on setup
  customer_name?: string | null;
  customer_phone?: string | null;
  customer_email?: string | null;
  order_type?: string; // e.g., 'dine_in', 'takeaway'
  table_number?: string | null;
  subtotal: number;
  vat_amount: number;
  discount_amount?: number | null;
  total_amount: number;
  payment_method: string; // e.g., 'cash', 'card', 'qr'
  payment_status?: string; // e.g., 'pending', 'paid'
  order_status?: string; // e.g., 'pending', 'completed'
  notes?: string | null;
  items: CartItemForSubmit[];
}


export const fetchPOSCategories = async (): Promise<POSMenuCategory[]> => {
  const { data, error } = await supabase
    .from('pos_menu_categories')
    .select('*')
    .eq('is_active', true)
    .order('display_order', { ascending: true })
    .order('name', { ascending: true });

  if (error) {
    console.error('Error fetching POS categories:', error);
    throw error;
  }
  return data || [];
};

export const fetchPOSMenuItems = async (): Promise<POSMenuItem[]> => {
  const { data, error } = await supabase
    .from('pos_menu_items')
    .select('*')
    .eq('is_available', true)
    .order('display_order', { ascending: true })
    .order('name', { ascending: true });

  if (error) {
    console.error('Error fetching POS menu items:', error);
    throw error;
  }
  return data || [];
};

export const submitPOSOrder = async (orderData: OrderSubmissionData): Promise<{ success: boolean; orderId?: string; orderNumber?: string; error?: any }> => {
  // 1. Create the main order record
  // The order_number is auto-generated by a trigger in your DB schema, so we don't send it.
  const orderToInsert = {
    cashier_id: orderData.cashier_id,
    customer_name: orderData.customer_name,
    customer_phone: orderData.customer_phone,
    customer_email: orderData.customer_email,
    order_type: orderData.order_type || 'dine_in',
    table_number: orderData.table_number,
    subtotal: orderData.subtotal,
    vat_amount: orderData.vat_amount,
    discount_amount: orderData.discount_amount || 0,
    total_amount: orderData.total_amount,
    payment_method: orderData.payment_method,
    payment_status: orderData.payment_status || 'paid', // Default to paid for POS
    order_status: orderData.order_status || 'completed', // Default to completed for POS
    notes: orderData.notes,
    // created_at is default, completed_at can be set if status is completed
    completed_at: (orderData.order_status || 'completed') === 'completed' ? new Date().toISOString() : null,
  };

  const { data: newOrder, error: orderError } = await supabase
    .from('pos_orders')
    .insert({
      ...orderToInsert,
      order_number: '' // This will be set by the trigger
    })
    .select()
    .single(); // Assuming insert returns the created row

  if (orderError || !newOrder) {
    console.error('Error creating order:', orderError);
    return { success: false, error: orderError || new Error("Failed to create order or receive order data.") };
  }

  // 2. Create order items records
  const orderItemsToInsert = orderData.items.map(item => ({
    order_id: newOrder.id,
    menu_item_id: item.menu_item_id,
    item_name: item.item_name, // Name at the time of purchase
    quantity: item.quantity,
    unit_price: item.unit_price, // Price at the time of purchase
    vat_rate: item.vat_rate, // VAT rate applied to this item
    vat_amount: item.vat_amount, // Calculated VAT for this line item
    total_amount: item.total_amount, // Total for this line item
    notes: item.notes,
  }));

  const { error: itemsError } = await supabase
    .from('pos_order_items')
    .insert(orderItemsToInsert);

  if (itemsError) {
    console.error('Error creating order items:', itemsError);
    // Potentially delete the created order if items fail (rollback logic)
    // This is where a transaction (via Edge Function) would be beneficial.
    // For now, we'll report the error.
    await supabase.from('pos_orders').delete().eq('id', newOrder.id); // Attempt to clean up
    return { success: false, error: itemsError };
  }

  // TODO: (Future) Update stock levels if pos_menu_items.track_stock is true

  return { success: true, orderId: newOrder.id, orderNumber: newOrder.order_number };
};
